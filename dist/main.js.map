{"version":3,"sources":["main.coffee"],"names":["global","window","this","_","lodash","require","addUnique","v","a","indexOf","length","firstAvailableKey","i","onAvailable","key","firstKey","firstValue","count","isNumeric","obj","parseFloat","setValue","name","value","current","nameParts","replace","split","bindec","bin","dec","reverse","Math","pow","decbin","bits","into","lastBit","floor","ceil","join","ucwords","string","newString","Array","$","each","substr","toUpperCase","decimals","precision","parts","remaining","round","repeat","hsc","escape","nl2br","br_hsc","flatten_keys","data","recurse","result","cur","prop","isEmpty","p","Object","isArray","flatten_to_input","bracketFlat","first","flat","k","newKey","shift","map","unflatten_input","o","new_o","isObject","Error","set","flatten_parts_to_input","picked","pick","assign","unflatten_input_parts","j","keys","len","unflat","push","morph","fn","morphCopy","copy","hasOwnProperty","lastOf","haystack","needles","last_needle","last_position","needle","position","lastIndexOf","bindSelf","functions","bind","makeInstance","re_call","callback","key_resolver","apply","arguments","isEqual","last_key","last_result","cache","WeakMap","tryJSON","json","e","JSON","parse","error","compare","o1","o2","diff","o1_flat","o1_keys","o2_flat","o2_keys","same_keys","missing_in_o2","difference","missing_in_o1","intersection","value_diff","pushes","arr","adds","add","contexted","list","context","partial","int","parseInt","float","number","toNumber","array","comform","arr_v","conform","conformed","isString","isInteger","isNumber","match","filter"],"mappings":"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","file":"main.js","sourcesContent":["`global= (typeof(global) != 'undefined' && global)  || (typeof(window) != 'undefined' && window) || this`\n_ = global.lodash || global._ || require('lodash')\nglobal._ = _ # overwrite potential underscore\n\n# Add, but only if unique\n_.addUnique = (v, a) ->\n\tif _.indexOf(a, v) == -1\n\t\ta[a.length] = v\n\treturn\n\n# get the first available key in a sequential array (where potentially some have been deteted\n\n_.firstAvailableKey = (a) ->\n\ti = 0\n\twhile i < a.length\n\t\tif typeof a[i] == 'undefined'\n\t\t\treturn i\n\t\ti++\n\ta.length\n\n# insert on first available key in a sequential array.  Returns key.\n\n_.onAvailable = (v, a) ->\n\tkey = _.firstAvailableKey(a)\n\ta[key] = v\n\tkey\n\n# get key of first existing element\n\n_.firstKey = (a) ->\n\ti = 0\n\twhile i < a.length\n\t\tif typeof a[i] != 'undefined'\n\t\t\treturn i\n\t\ti++\n\tfalse\n\n# get first existing element\n\n_.firstValue = (a) ->\n\tkey = _.firstKey(a)\n\ta[key]\n\n# ignore unset elements (since deleted values still count towards length)\n\n_.count = (a) ->\n\tcount = 0\n\tfor i of a\n\t\tcount += 1\n\tcount\n\n#  see jquery\n\n_.isNumeric = (v) ->\n\tif typeof v == typeof 1 or typeof v == typeof '1'\n\t\treturn obj - parseFloat(obj) + 1 >= 0\n\treturn\n\n# set arbitrarily deep path to value use standard http form array input semantics\n\n###*\nex\n\tsetValue('interest[1][name]','test',data);  => { interest: { '1': { name: 'test' } } }\n###\n\n_.setValue = (name, value, obj) ->\n\tnameParts = name.replace(/\\]/g, '').split(/\\[/)\n\tcurrent = obj\n\ti = 0\n\twhile i < nameParts.length - 1\n\t\tif !current[nameParts[i]]\n\t\t\tcurrent[nameParts[i]] = {}\n\t\t#since objs are moved by reference, this obj attribute of parent obj still points to parent attribute obj\n\t\tcurrent = current[nameParts[i]]\n\t\ti++\n\tcurrent[nameParts[nameParts.length - 1]] = value\n\treturn\n\n# Binary to decimal\n\n_.bindec = (bin) ->\n\tbin = (bin + '').split('').reverse()\n\tdec = 0\n\ti = 0\n\twhile i < bin.length\n\t\tif bin[i] == 1\n\t\t\tdec += 2 ** i\n\t\ti++\n\tdec\n\n# Decimal to binary\n\n_.decbin = (dec) ->\n\tbits = ''\n\tinto = dec\n\twhile into >= 1\n\t\tbits += into % 2\n\t\tinto = Math.floor(into / 2)\n\tlastBit = Math.ceil(into)\n\tif lastBit\n\t\tbits += lastBit\n\tbits.split('').reverse().join ''\n\n# set words to upper case\n\n### better, non-dependent, coffee version\n_.ucwords = (string)->\n\tif string\n\t\treturn (string.split(' ').map (v)->\n\t\t\tv[0].toUpperCase() + v[1..]).join(' ')\n###\n\n_.ucwords = (string) ->\n\tif string\n\t\tstring = string.split(' ')\n\t\tnewString = Array()\n\t\ti = 0\n\t\t$.each string, ->\n\t\t\tnewString[newString.length] = @substr(0, 1).toUpperCase() + @substr(1, @length)\n\t\t\treturn\n\t\treturn newString.join(' ')\n\treturn\n\n#  show number or string as some string-number with some amount of decimals\n\n_.decimals = (string, precision) ->\n\tstring = _.round(string, precision) + ''\n\tparts = string.split('.')\n\tif parts.length == 2\n\t\tremaining = precision - (parts[1].length)\n\t\tstring + '0'.repeat(remaining)\n\telse if precision > 0\n\t\tstring + '.' + '0'.repeat(precision)\n\telse\n\t\tstring\n\n# htmlspecialchars() - for escaping text\n\n_.hsc = (string) ->\n\tif string == null\n\t\treturn ''\n\t_.escape(string)\n\t# seems to be not-uneccesary to use jquery for this\n\t# $('<a></a>').text(string).html()\n\n_.nl2br = (string) ->\n\tstring.replace /(?:\\r\\n|\\r|\\n)/g, '<br />'\n_.br_hsc = (string)->\n\t_.nl2br _.hsc(string)\n\n# flatten keys of object with . separation\n\n_.flatten_keys = (data) ->\n\tresult = {}\n\n\trecurse = (cur, prop) ->\n\t\tif Object(cur) != cur or Array.isArray(cur)\n\t\t\tresult[prop] = cur\n\t\telse\n\t\t\tisEmpty = true\n\t\t\tfor p of cur\n\t\t\t\tisEmpty = false\n\t\t\t\trecurse cur[p], if prop then prop + '.' + p else p\n\t\t\tif isEmpty and prop\n\t\t\t\tresult[prop] = {}\n\t\treturn\n\n\trecurse data, ''\n\tresult\n\n# turn a js object into form-name-style flat object.  Ex {bob:{bobs:'bill'}} => {'bob[bobs]':'bill'}\n\n# @NOTE  does not mutate object\n_.flatten_to_input = (data) ->\n\tflat = _.flatten_keys(data)\n\tbracketFlat = {}\n\tname = undefined\n\t# remove the \".\" separation\n\tfor k of flat\n\t\tname = k\n\t\t# add \"[]\" to array values\n\t\tif Array.isArray(flat[k])\n\t\t\tname += '[]'\n\t\tparts = name.split('.')\n\t\tif parts.length > 1\n\t\t\t#first key is not bracketted: ex: bob[bill]\n\t\t\tfirst = parts.shift()\n\t\t\tparts = parts.map((v) ->\n\t\t\t\t'[' + v + ']'\n\t\t\t)\n\t\t\tnewKey = first + parts.join('')\n\t\t\tbracketFlat[newKey] = flat[k]\n\t\telse\n\t\t\tbracketFlat[name] = flat[k]\n\tbracketFlat\n\n# @NOTE does not mutate object\n_.unflatten_input = (o)->\n\tif _.isArray(o) || !_.isObject(o)\n\t\tthrow new Error('wrong type')\n\tnew_o = {}\n\tfor k, v of o\n\t\t_.set(new_o, k, v)\n\tnew_o\n\n# for some object, flatten some keys\n# @NOTE mutates object\n_.flatten_parts_to_input = (o, parts)->\n\tif _.isArray(o) || !_.isObject(o)\n\t\tthrow new Error('wrong type')\n\tpicked = _.pick(o,parts)\n\tflat = _.flatten_to_input(picked)\n\tfor k of picked\n\t\tdelete o[k]\n\to = _.assign(o, flat)\n# unflatten some keys, based on original unflat key name\n# @NOTE mutates object\n_.unflatten_input_parts = (o, parts)->\n\tif _.isArray(o) || !_.isObject(o)\n\t\tthrow new Error('wrong type')\n\tkeys = []\n\tfor k of o\n\t\tif parts.indexOf(k.split('[',1)[0]) != -1\n\t\t\tkeys.push k\n\tpicked = _.pick(o,keys)\n\tunflat = _.unflatten_input(picked)\n\n\tfor k in keys\n\t\tdelete o[k]\n\to = _.assign(o, unflat)\n\n# like map, but uses and returns obj instead of array\n\n_.morph = (obj, fn) ->\n\tfor key of obj\n\t\tobj[key] = fn(obj[key], key)\n\tobj\n\n_.morphCopy = (obj, fn) ->\n\tcopy = undefined\n\tif _.isArray(obj)\n\t\tcopy = []\n\telse\n\t\tcopy = {}\n\t#copy = new obj.constructor()\n\tfor key of obj\n\t\tif obj.hasOwnProperty(key)\n\t\t\tcopy[key] = fn(obj[key], key)\n\tcopy\n\n# _.lastOf(['bill','no','no'], ['bill','no','bills']) #> {position: 2, needle: \"no\"}\n_.lastOf =(haystack, needles)->\n\tlast_position = -1\n\tlast_needle = false\n\tfor needle, i in needles\n\t\tposition = haystack.lastIndexOf needle\n\t\tif position > last_position\n\t\t\tlast_position = position\n\t\t\tlast_needle =  needle\n\treturn {position: last_position, needle: last_needle}\n# bind all functions to self\n_.bindSelf = (obj)->\n\t_.functions(obj).map (key)-> # bind keys to self\n\t\tobj[key] = obj[key].bind(obj)\n\n\n\n# turn an object into an instance with \"this\" mapped to the object keys.  Useful when a pre-keyed \"this\" is needed\n_.makeInstance = (obj)->\n\tnew ()->\n\t\tfor k,v of obj\n\t\t\t@[k] = v\n\t\t@\n\n\n# like memoize, but only returns cache on consecutive-same calls\n_.re_call = (callback, key_resolver)->\n\tre_call = ()->\n\t\tkey = key_resolver?.apply(this, arguments) || arguments\n\t\tif _.isEqual(re_call.last_key, key)\n\t\t\treturn re_call.last_result\n\t\tresult = callback.apply(this,arguments)\n\t\tre_call.last_key = key\n\t\tre_call.last_result = result\n\n\t\treturn result\n\tre_call.cache = new WeakMap\n\treturn re_call\n# catch JSON.parse exception and warn.  chrome error-on-bad-json-syntax is cryptic, so, instead, grab and warn\n_.tryJSON = (json)->\n\ttry\n\t\treturn JSON.parse(json)\n\tcatch e\n\t\treturn undefined\n# find obj difference with dot notation\n_.compare = (o1, o2)->\n\to1_flat = _.flatten_keys(o1)\n\to2_flat = _.flatten_keys(o2)\n\to1_keys = _.keys(o1_flat)\n\to2_keys = _.keys(o2_flat)\n\tdiff = {}\n\tdiff.missing_in_o2 = _.difference(o1_keys, o2_keys)\n\tdiff.missing_in_o1 = _.difference(o2_keys, o1_keys)\n\tsame_keys = _.intersection(o1_keys, o2_keys)\n\tdiff.value_diff = {}\n\tfor key in same_keys\n\t\tif o1_flat[key] != o2_flat[key]\n\t\t\tdiff.value_diff[key] = {o1:o1_flat[key], o2:o2_flat[key]}\n\tdiff\n\n# push if arg is not array, otherwise push each of array\n_.pushes = (arr, adds)->\n\tif _.isArray(adds)\n\t\tfor add in adds\n\t\t\tarr.push(add)\n\telse\n\t\tarr.push(adds)\n\tarr\n\n# take a list of functions, and return a list of those functions with a shared context object between them as the first argument\n### Ex\nsequence = [\n\t(context, result)-> Promise.delay(1000).then(()->'bob1'),\n\t(context, result)-> Promise.delay(100).then(()->'bob2'),\n]\nPromise.sequence(_.contexted(sequence)).then (r)->\n\tc arguments\n###\n_.contexted = (list, context={})->\n\tcontext={}\n\tlist.map (fn)-> _.partial(fn, context)\n\n\n# convert to number, w/o NaN\n_.int = (v)->\n\tparseInt(v) || 0\n# convert to number, w/o NaN\n_.float = (v)->\n\tparseFloat(v) || 0.0\n_.number = (v)->\n\t_.toNumber(v) || 0\n# if not array, make array with `v` as first element\n_.array = (v)->\n\tif !_.isArray(v)\n\t\treturn [v]\n\treturn v\n\n# Without a `conform` fn, comforms array values to the searched value for comparison, and returns true or false\n_.in = (arr, v, comform)->\n\tif !conform\n\t\tif _.isString(v)\n\t\t\tconform = (v)-> ''+v\n\t\telse if _.isInteger(v)\n\t\t\tconform = (v)-> parseInt v\n\t\telse if _.isNumber(v)\n\t\t\tconform = (v)-> parseFloat v\n\t\telse\n\t\t\tconform = (v)-> v\n\n\tfor arr_v in arr\n\t\tconformed = conform(arr_v)\n\t\tif conformed == v\n\t\t\treturn true\n\treturn false\n\n# filter on exact match\n_.delete = (arr, match)->\n\tarr.filter (v)->\n\t\tv != match"],"sourceRoot":"/source/"}